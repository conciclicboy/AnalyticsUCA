make_pdf_file = 0 # Haga este número 1 si quiere un archivo PDF, 0 para HTML
print(getwd())
source("../../AnalyticsLibraries/library.R")
source("../../AnalyticsLibraries/heatmapOutput.R")
# Opciones de paquetes
ggthemr('fresh')  # tema de ggplot
opts_knit$set(progress=FALSE, verbose=FALSE)
opts_chunk$set(echo=FALSE, fig.align="center", fig.width=10, fig.height=6.2)
options(knitr.kable.NA = '')
make_pdf_file = 0 # Haga este número 1 si quiere un archivo PDF, 0 para HTML
print(getwd())
source("../../AnalyticsLibraries/library.R")
source("../../AnalyticsLibraries/heatmapOutput.R")
# Opciones de paquetes
ggthemr('fresh')  # tema de ggplot
opts_knit$set(progress=FALSE, verbose=FALSE)
opts_chunk$set(echo=FALSE, fig.align="center", fig.width=10, fig.height=6.2)
options(knitr.kable.NA = '')
make_pdf_file = 0 # Haga este número 1 si quiere un archivo PDF, 0 para HTML
print(getwd())
source("../../AnalyticsLibraries/library.R")
source("../../AnalyticsLibraries/heatmapOutput.R")
# Opciones de paquetes
ggthemr('fresh')  # tema de ggplot
opts_knit$set(progress=FALSE, verbose=FALSE)
opts_chunk$set(echo=FALSE, fig.align="center", fig.width=10, fig.height=6.2)
options(knitr.kable.NA = '')
# Por favor INGRESE el nombre del archivo
datafile_name = "../../Data/UCI_Credit_Card.csv"
ProjectData <- read.csv(datafile_name)
# Convertimos los datos a la clase data.matrix para que sea mas fácil de manipular
ProjectData <- data.matrix(ProjectData)
# Por favor INGRESE la variable dependiente(clase).
# Por favor use números, no nombres de columnas. Por ejemplo, 82 usa la columna en la posición 82 como la variable dependiente.
# Necesita asegurarse que la variable dependiente solo tome dos valores: 0 y 1.
dependent_variable = 25
# Por favor ingrese los atributos a usar como variables independientes.
# Por favor use números, no nombres de columnas. Por ejemplo, c(1:5, 7, 8) usa las columnas 1,2,3,4,5,7,8.
independent_variables = c(1:24) # usa todos los atributos disponibles
dependent_variable = unique(sapply(dependent_variable,function(i) min(ncol(ProjectData), max(i,1))))
independent_variables = unique(sapply(independent_variables,function(i) min(ncol(ProjectData), max(i,1))))
if (length(unique(ProjectData[,dependent_variable])) !=2){
cat("\n*****\n REVISE DE NUEVO, LA VARIABLE DEPENDIENTE TOMA MÁS DE 2 VALORES")
cat("\nDividiendo los datos respecto a la mediana...\n*****\n ")
new_dependent = ProjectData[,dependent_variable] >= median(ProjectData[,dependent_variable])
ProjectData[,dependent_variable] <- 1*new_dependent
}
# Por favor INGRESE el umbral de probabilidad arriba del cual una observación será categorizada como clase 1:
Probability_Threshold = 0.5 # entre 0 y 1
# Por favor INGRESE el porcentaje de datos usados para la estimación
estimation_data_percent = 80
validation_data_percent = 10
test_data_percent = 100-estimation_data_percent-validation_data_percent
# Por favor INGRESE 1 si quiere dividir los datos aleatoriamente en los conjuntos de estimación y validación/evaluación
random_sampling = 0
# Parámetros del árbol
# Por favor INGRESE el control de complejidad cp del árbol(CART), por ejemplo de 0.0001 a 0.02, dependiendo de los datos.
CART_cp = 0.0025
CART_control = rpart.control(cp = CART_cp)
# Por favor INGRESE el significado de las clases 1 y 0:
class_1_interpretation = "default"
class_0_interpretation = "no default"
# Por favor INGRESE los valores de ganancia/costo de clasificar correcta o incorrectamente los datos:
actual_1_predict_1 = 0
actual_1_predict_0 = -100000
actual_0_predict_1 = 0
actual_0_predict_0 = 20000
Profit_Matrix = matrix(c(actual_1_predict_1, actual_0_predict_1, actual_1_predict_0, actual_0_predict_0), ncol=2)
colnames(Profit_Matrix) <- c(paste("Predict 1 (", class_1_interpretation, ")", sep = ""), paste("Predict 0 (", class_0_interpretation, ")", sep = ""))
rownames(Profit_Matrix) <- c(paste("Actual 1 (", class_1_interpretation, ")", sep = ""), paste("Actual 0 (", class_0_interpretation, ")", sep = ""))
# Por favor INGRESE el máximo número de observaciones a mostrar en el reporte y diapositivas
# (El número predefinido es 50. Si el número es demasiado grande el reporte y las diapositivas podrían no ser generados -  muy lento o no funcionará!!)
max_data_report = 10
knitr::kable({
df <- t(head(round(ProjectData[,independent_variables],2), max_data_report))
colnames(df) <- sprintf("%02d", 1:ncol(df))
df
})
if (random_sampling){
estimation_data_ids=sample.int(nrow(ProjectData),floor(estimation_data_percent*nrow(ProjectData)/100))
non_estimation_data = setdiff(1:nrow(ProjectData),estimation_data_ids) #setdiff(x,y) returns the elements of x that are not in y
validation_data_ids=non_estimation_data[sample.int(length(non_estimation_data), floor(validation_data_percent/(validation_data_percent+test_data_percent)*length(non_estimation_data)))]
} else {
estimation_data_ids=1:floor(estimation_data_percent*nrow(ProjectData)/100)
non_estimation_data = setdiff(1:nrow(ProjectData),estimation_data_ids)
validation_data_ids = (tail(estimation_data_ids,1)+1):(tail(estimation_data_ids,1) + floor(validation_data_percent/(validation_data_percent+test_data_percent)*length(non_estimation_data)))
}
test_data_ids = setdiff(1:nrow(ProjectData), union(estimation_data_ids,validation_data_ids))
estimation_data=ProjectData[estimation_data_ids,]
validation_data=ProjectData[validation_data_ids,]
test_data=ProjectData[test_data_ids,]
class_percentages=matrix(c(sum(estimation_data[,dependent_variable]==1),sum(estimation_data[,dependent_variable]==0)), nrow=1); colnames(class_percentages)<-c("Class 1", "Class 0")
rownames(class_percentages)<-"# of Observations"
knitr::kable(class_percentages)
class_percentages=matrix(c(sum(validation_data[,dependent_variable]==1),sum(validation_data[,dependent_variable]==0)), nrow=1); colnames(class_percentages)<-c("Class 1", "Class 0")
rownames(class_percentages)<-"# of Observations"
knitr::kable(class_percentages)
knitr::kable(round(my_summary(estimation_data[estimation_data[,dependent_variable]==1,independent_variables]),2))
knitr::kable(round(my_summary(estimation_data[estimation_data[,dependent_variable]==0,independent_variables]),2))
# Please ENTER the selected independent variables for which to draw box plots.
# Please use numbers, not column names. E.g., c(1:5, 7, 8) uses columns 1,2,3,4,5,7,8.
boxplots_independent_variables = c(7:12) # use only the PAY_ variables
DVvalues = unique(estimation_data[,dependent_variable])
x0 = estimation_data[which(estimation_data[,dependent_variable]==DVvalues[1]),boxplots_independent_variables]
x1 = estimation_data[which(estimation_data[,dependent_variable]==DVvalues[2]),boxplots_independent_variables]
colnames(x0) <- 1:ncol(x0)
colnames(x1) <- 1:ncol(x1)
swatch.default <- as.character(swatch())
set_swatch(c(swatch.default[1], colorRampPalette(RColorBrewer::brewer.pal(12, "Paired"))(ncol(x1))))
ggplot(melt(cbind.data.frame(n=1:nrow(x1), x1), id="n"), aes(x=n, y=value, colour=variable)) + geom_boxplot(fill="#FFFFFF", size=0.66, position=position_dodge(1.1*nrow(x1)))
set_swatch(swatch.default)
# Please ENTER the selected independent variables for which to draw box plots.
# Please use numbers, not column names. E.g., c(1:5, 7, 8) uses columns 1,2,3,4,5,7,8.
boxplots_independent_variables = c(7:12) # use only the PAY_ variables
DVvalues = unique(estimation_data[,dependent_variable])
x0 = estimation_data[which(estimation_data[,dependent_variable]==DVvalues[1]),boxplots_independent_variables]
x1 = estimation_data[which(estimation_data[,dependent_variable]==DVvalues[2]),boxplots_independent_variables]
colnames(x0) <- 1:ncol(x0)
colnames(x1) <- 1:ncol(x1)
swatch.default <- as.character(swatch())
set_swatch(c(swatch.default[1], colorRampPalette(RColorBrewer::brewer.pal(12, "Paired"))(ncol(x1))))
ggplot(melt(cbind.data.frame(n=1:nrow(x1), x1), id="n"), aes(x=n, y=value, colour=variable)) + geom_boxplot(fill="#FFFFFF", size=0.66, position=position_dodge(1.1*nrow(x1)))
set_swatch(swatch.default)
# We first turn the data into data.frame's
estimation_data = data.frame(estimation_data)
validation_data = data.frame(validation_data)
test_data = data.frame(test_data)
formula_log=paste(colnames(estimation_data[,dependent_variable,drop=F]),paste(Reduce(paste,sapply(head(independent_variables,-1), function(i) paste(colnames(estimation_data)[i],"+",sep=""))),colnames(estimation_data)[tail(independent_variables,1)],sep=""),sep="~") # When drop is FALSE, the dimensions of the object are kept. head(x,-1) returns all but the last element of x.
logreg_solution <- glm(formula_log, family=binomial(link="logit"),  data=estimation_data)
log_coefficients <- round(summary(logreg_solution)$coefficients,1)
knitr::kable(round(log_coefficients,2))
swatch.default <- as.character(swatch())
set_swatch(c(swatch.default[1], colorRampPalette(RColorBrewer::brewer.pal(12, "Paired"))(ncol(x0))))
ggplot(melt(cbind.data.frame(n=1:nrow(x0), x0), id="n"), aes(x=n, y=value, colour=variable)) + geom_boxplot(fill="#FFFFFF", size=0.66, position=position_dodge(1.1*nrow(x0)))
set_swatch(swatch.default)
# We first turn the data into data.frame's
estimation_data = data.frame(estimation_data)
validation_data = data.frame(validation_data)
test_data = data.frame(test_data)
formula_log=paste(colnames(estimation_data[,dependent_variable,drop=F]),paste(Reduce(paste,sapply(head(independent_variables,-1), function(i) paste(colnames(estimation_data)[i],"+",sep=""))),colnames(estimation_data)[tail(independent_variables,1)],sep=""),sep="~") # When drop is FALSE, the dimensions of the object are kept. head(x,-1) returns all but the last element of x.
logreg_solution <- glm(formula_log, family=binomial(link="logit"),  data=estimation_data)
log_coefficients <- round(summary(logreg_solution)$coefficients,1)
knitr::kable(round(log_coefficients,2))
# Let's get the probabilities for the 3 types of data from the logistic regression
estimation_Probability_class1_log<-predict(logreg_solution, type="response", newdata=estimation_data[,independent_variables])
validation_Probability_class1_log<-predict(logreg_solution, type="response", newdata=validation_data[,independent_variables])
test_Probability_class1_log<-predict(logreg_solution, type="response", newdata=test_data[,independent_variables])
# Let's get the decision of the logistic regression for the 3 types of data
estimation_prediction_class_log=1*as.vector(estimation_Probability_class1_log > Probability_Threshold)
validation_prediction_class_log=1*as.vector(validation_Probability_class1_log > Probability_Threshold)
test_prediction_class_log=1*as.vector(test_Probability_class1_log > Probability_Threshold)
Classification_Table=rbind(validation_data[,dependent_variable],validation_prediction_class_log,validation_Probability_class1_log)
rownames(Classification_Table)<-c("Actual Class","Predicted Class","Probability of Class 1")
colnames(Classification_Table)<- paste("Obs", 1:ncol(Classification_Table), sep=" ")
knitr::kable(head(t(round(Classification_Table,2)), max_data_report)) #t(x) returns the transpose of x
# Name the variables numerically so that they look ok on the tree plots
independent_variables_nolabel = paste("IV", 1:length(independent_variables), sep="")
estimation_data_nolabel = cbind(estimation_data[,dependent_variable], estimation_data[,independent_variables])
colnames(estimation_data_nolabel)<- c(colnames(estimation_data)[dependent_variable],independent_variables_nolabel)
validation_data_nolabel = cbind(validation_data[,dependent_variable], validation_data[,independent_variables])
colnames(validation_data_nolabel)<- c(dependent_variable,independent_variables_nolabel)
test_data_nolabel = cbind(test_data[,dependent_variable], test_data[,independent_variables])
colnames(test_data_nolabel)<- c(dependent_variable,independent_variables_nolabel)
estimation_data_nolabel = data.frame(estimation_data_nolabel)
validation_data_nolabel = data.frame(validation_data_nolabel)
test_data_nolabel = data.frame(test_data_nolabel)
formula=paste(colnames(estimation_data)[dependent_variable],paste(Reduce(paste,sapply(head(independent_variables_nolabel,-1), function(i) paste(i,"+",sep=""))),tail(independent_variables_nolabel,1),sep=""),sep="~")
CART_tree<-rpart(formula, data= estimation_data_nolabel,method="class", control=CART_control)
rpart.plot(CART_tree, box.palette="OrBu", type=3, extra=1, fallen.leaves=F, branch.lty=3)
# Tree parameter
# Please ENTER the new tree (CART) complexity control cp
CART_cp = 0.00068
CART_tree_large<-rpart(formula, data= estimation_data_nolabel,method="class", control=rpart.control(cp = CART_cp))
rpart.plot(CART_tree_large, box.palette="OrBu", type=3, extra=1, fallen.leaves=F, branch.lty=3)
make_pdf_file = 0 # Haga este número 1 si quiere un archivo PDF, 0 para HTML
source("../../AnalyticsLibraries/library.R")
source("../../AnalyticsLibraries/heatmapOutput.R")
# Opciones de paquetes
ggthemr('fresh')  # tema de ggplot
opts_knit$set(progress=FALSE, verbose=FALSE)
opts_chunk$set(echo=FALSE, fig.align="center", fig.width=10, fig.height=6.2)
options(knitr.kable.NA = '')
# Por favor INGRESE el nombre del archivo
datafile_name = "../../Data/UCI_Credit_Card.csv"
ProjectData <- read.csv(datafile_name)
# Convertimos los datos a la clase data.matrix para que sea mas fácil de manipular
ProjectData <- data.matrix(ProjectData)
# Por favor INGRESE la variable dependiente(clase).
# Por favor use números, no nombres de columnas. Por ejemplo, 82 usa la columna en la posición 82 como la variable dependiente.
# Necesita asegurarse que la variable dependiente solo tome dos valores: 0 y 1.
dependent_variable = 25
# Por favor ingrese los atributos a usar como variables independientes.
# Por favor use números, no nombres de columnas. Por ejemplo, c(1:5, 7, 8) usa las columnas 1,2,3,4,5,7,8.
independent_variables = c(1:24) # usa todos los atributos disponibles
dependent_variable = unique(sapply(dependent_variable,function(i) min(ncol(ProjectData), max(i,1))))
independent_variables = unique(sapply(independent_variables,function(i) min(ncol(ProjectData), max(i,1))))
if (length(unique(ProjectData[,dependent_variable])) !=2){
cat("\n*****\n REVISE DE NUEVO, LA VARIABLE DEPENDIENTE TOMA MÁS DE 2 VALORES")
cat("\nDividiendo los datos respecto a la mediana...\n*****\n ")
new_dependent = ProjectData[,dependent_variable] >= median(ProjectData[,dependent_variable])
ProjectData[,dependent_variable] <- 1*new_dependent
}
# Por favor INGRESE el umbral de probabilidad arriba del cual una observación será categorizada como clase 1:
Probability_Threshold = 0.5 # entre 0 y 1
# Por favor INGRESE el porcentaje de datos usados para la estimación
estimation_data_percent = 80
validation_data_percent = 10
test_data_percent = 100-estimation_data_percent-validation_data_percent
# Por favor INGRESE 1 si quiere dividir los datos aleatoriamente en los conjuntos de estimación y validación/evaluación
random_sampling = 0
# Parámetros del árbol
# Por favor INGRESE el control de complejidad cp del árbol(CART), por ejemplo de 0.0001 a 0.02, dependiendo de los datos.
CART_cp = 0.0025
CART_control = rpart.control(cp = CART_cp)
# Por favor INGRESE el significado de las clases 1 y 0:
class_1_interpretation = "default"
class_0_interpretation = "no default"
# Por favor INGRESE los valores de ganancia/costo de clasificar correcta o incorrectamente los datos:
actual_1_predict_1 = 0
actual_1_predict_0 = -100000
actual_0_predict_1 = 0
actual_0_predict_0 = 20000
Profit_Matrix = matrix(c(actual_1_predict_1, actual_0_predict_1, actual_1_predict_0, actual_0_predict_0), ncol=2)
colnames(Profit_Matrix) <- c(paste("Predict 1 (", class_1_interpretation, ")", sep = ""), paste("Predict 0 (", class_0_interpretation, ")", sep = ""))
rownames(Profit_Matrix) <- c(paste("Actual 1 (", class_1_interpretation, ")", sep = ""), paste("Actual 0 (", class_0_interpretation, ")", sep = ""))
# Por favor INGRESE el máximo número de observaciones a mostrar en el reporte y diapositivas
# (El número predefinido es 50. Si el número es demasiado grande el reporte y las diapositivas podrían no ser generados -  muy lento o no funcionará!!)
max_data_report = 10
